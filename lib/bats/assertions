#! /bin/bash
#
# Assertions for Bats tests
#
# Provides detailed output for assertion failures, which is especially helpful
# when running as part of a continuous integration suite.
#
# The recommended way to make these assertions available is to create an
# 'environment.bash' file in the top-level test directory containing the
# following line:
#
#   . "path/to/bats/assertions"
#
# Then have each Bats test file load the environment file. This environment file
# can contain any other custom helper functions or assertions to fit your
# project.
#
# If none of the assertions suit your needs, you can use the fail() function to
# provide a custom error message. For example, to validate that the command
# output does _not_ match a regular expression:
#
#   local pattern="what is this i don't even"
#   if [[ "$output" =~ $pattern ]]; then
#     fail "output should not match: '$pattern'"
#   fi
#
# Alternatively, write your own assertion function with the following as the
# first line:
#
#   set +o functrace
#
# and then make sure every return path ends with the following (possibly
# followed by a `return` statement, if not at the end of the function):
#
#   return_from_bats_assertion "$return_status" "$BASH_SOURCE"
#
# You may wish to wrap `return_from_bats_assertion` in a local helper function
# to avoid having to specify `$BASH_SOURCE` everywhere.
#
# Also note that if your assertion function calls other assertion functions, you
# should call `set +o functrace` after every one of them. See the implementation
# of `assert_lines_equal` for an example.
#
# The assertions borrow inspiration from rbenv/test/test_helper.bash.

# Unconditionally returns a failing status
#
# Will print an optional failure reason, the Bats 'run' command exit status, and
# the output from the 'run' command, all to standard error.
#
# Arguments:
#   $1:  (optional) Reason to include in the failure output
fail() {
  set +o functrace
  local reason="$1"

  if [[ -n "$reason" ]]; then
    printf '%b\n' "$reason" >&2
  fi
  if [[ -z "$__bats_fail_suppress_output" ]]; then
    printf 'STATUS: %d\nOUTPUT:\n%b\n' "$status" "$output" >&2
  fi
  __return_from_bats_assertion 1
}

# Negates the expected outcome of an assertion from this file.
#
# The first argument should be the name of an assertion from this file _without_
# the `assert_` prefix. For example:
#
#   fail_if equal 'foo' 'bar' "Some values we don't expect to be equal"
#
# This is essentially the same as the following, but `fail_if` provides more
# context for the failure:
#
#   ! assert_equal 'foo' 'bar' "Some values we don't expect to be equal"
#
# Arguments:
#   assertion:  The name of the assertion to negate minus the `_assert_` prefix
#   ...:        The arguments to the assertion being negated
fail_if() {
  set +o functrace
  local assertion="assert_${1}"
  shift
  local label
  local operation='equal'
  local constraints=()
  local constraint
  local i
  local __bats_fail_suppress_output='true'

  if [[ "$assertion" =~ _match ]]; then
    operation='match'
  fi

  case "$assertion" in
  assert_equal|assert_matches)
    label="$3"
    constraints=("$1")
    ;;
  assert_output*|assert_status)
    label="${assertion#assert_}"
    label="${label%_*}"
    constraints=("$1")
    ;;
  assert_line_*)
    label="line $1"
    constraints=("$2")
    ;;
  assert_lines_*)
    __bats_fail_suppress_output=
    label="lines"
    constraints=("${@}")
    ;;
  *)
    printf "Unknown assertion: '%s'\n" "$assertion" >&2
    __return_from_bats_assertion '1'
    return 1
  esac

  if ! "$assertion" "$@" &>/dev/null; then
    set +o functrace
    __return_from_bats_assertion '0'
    return
  fi
  set +o functrace

  for ((i=0; i != ${#constraints[@]}; ++i)); do
    constraint+=$'\n'"  '${constraints[$i]}'"
  done
  fail "Expected $label not to $operation:$constraint"
}

# Compares two values for equality
#
# Arguments:
#   $1: The expected value
#   $2: The actual value to evaluate
#   $3: A label explaining the value being evaluated
assert_equal() {
  set +o functrace
  local expected="$1"
  local actual="$2"
  local label="$3"

  if [[ "$expected" != "$actual" ]]; then
    printf '%s not equal to expected value:\n  %s\n  %s\n' \
      "$label" "expected: '$expected'" "actual:   '$actual'" >&2
    __return_from_bats_assertion 1
  else
    __return_from_bats_assertion
  fi
}

# Validates whether a value matches a regular expression
#
# Arguments:
#   $1: The regular expression to match against the value
#   $2: The value to match
#   $3: A label explaining the value being matched
assert_matches() {
  set +o functrace
  local pattern="$1"
  local value="$2"
  local label="$3"

  if [[ ! "$value" =~ $pattern ]]; then
    printf '%s does not match expected pattern:\n  %s\n  %s\n' \
      "$label" "pattern: '$pattern'" "value:   '$value'" >&2
    __return_from_bats_assertion 1
  else
    __return_from_bats_assertion
  fi
}

# Validates that the Bats $output value is equal to the expected value
#
# Arguments:
#   $1: The expected value for $output
assert_output() {
  set +o functrace
  __assert_output 'assert_equal' "$@"
}

# Validates that the Bats $output value matches a regular expression
#
# Arguments:
#   $1: The regular expression to match against $output
assert_output_matches() {
  set +o functrace
  __assert_output 'assert_matches' "$@"
}

# Validates that the Bats $status value is equal to the expected value
#
# Arguments:
#   $1: The expected value for $status
assert_status() {
  set +o functrace
  assert_equal "$1" "$status" "exit status"
}

# Validates that 'run' returned success and $output equals the expected value
#
# Arguments:
#   $1: The regular expression to match against $output
assert_success() {
  set +o functrace
  if [[ "$status" -ne '0' ]]; then
    printf 'expected success, but command failed\n' >&2
    fail
  elif [[ "$#" -ne 0 ]]; then
    assert_output "$@"
  else
    __return_from_bats_assertion
  fi
}

# Validates that 'run' returned an error and $output equals the expected value
#
# Arguments:
#   $1: The regular expression to match against $output
assert_failure() {
  set +o functrace
  if [[ "$status" -eq '0' ]]; then
    printf 'expected failure, but command succeeded\n' >&2
    fail
  elif [[ "$#" -ne 0 ]]; then
    assert_output "$@"
  else
    __return_from_bats_assertion
  fi
}

# Validates that a specific line from $line equals the expected value
#
# Arguments:
#   $1: The index into $line identifying the line to evaluate
#   $2: The expected value for ${line[$1]}
assert_line_equals() {
  set +o functrace
  __assert_line 'assert_equal' "$@"
}

# Validates that a specific line from $line equals the expected value
#
# Arguments:
#   $1: The index into $line identifying the line to match
#   $2: The regular expression to match against ${line[$1]}
assert_line_matches() {
  set +o functrace
  __assert_line 'assert_matches' "$@"
}

# Validates that each output line equals each corresponding argument
#
# Also ensures there are no more and no fewer lines of output than expected.
#
# Arguments:
#   $@: Values to compare to each element of `${lines[@]}` for equality
assert_lines_equal() {
  set +o functrace
  local expected=("$@")
  local num_lines="${#expected[@]}"
  local lines_diff="$((${#lines[@]} - num_lines))"
  local num_errors=0
  local i

  for ((i=0; i != ${#expected[@]}; ++i)); do
    if ! assert_equal "${expected[$i]}" "${lines[$i]}" "line $i"; then
      ((++num_errors))
    fi
    set +o functrace
  done

  if [[ "$lines_diff" -gt '0' ]]; then
    if [[ "$lines_diff" -eq '1' ]]; then
      echo "There is one more line of output than expected:" >&2
    else
      echo "There are $lines_diff more lines of output than expected:" >&2
    fi
    local IFS=$'\n'
    echo "${lines[*]:$num_lines}" >&2
    ((++num_errors))

  elif [[ "$lines_diff" -lt '0' ]]; then
    lines_diff="$((-lines_diff))"
    if [[ "$lines_diff" -eq '1' ]]; then
      echo "There is one fewer line of output than expected." >&2
    else
      echo "There are $lines_diff fewer lines of output than expected." >&2
    fi
    ((++num_errors))
  fi

  if [[ "$num_errors" -ne '0' ]]; then
    __return_from_bats_assertion 1
  fi
}

# Scrubs the Bats stacks of functions from the assertion source file
#
# You must ensure that `set +o functrace` is in effect prior to calling this
# function. If you write an assertion function that uses an assertion from this
# file, or which uses any other assertion that evantually calls this function,
# you will need to call `set +o functrace` again following those assertions.
#
# This helps ensure that Bats failure messages only contain the location at
# which an assertion was called, rather than containing stack trace information
# about the assertion implementation itself.
#
# Bats sets 'functrace' to make sure failing commands are pinpointed. This is
# almost always the desired behavior, except that we don't actually want a stack
# trace showing assertion implementation details. When it does, it produces a
# bit of mental overhead when reviewing test failures to identify the location
# of the failing assertion in the test case itself.
#
# Notice that each public assertion function starts with 'set +o functrace', and
# this function ends with 'set -o functrace'. However, just calling 'set +o
# functrace' still leaves the function, file, and line number where the
# assertion was defined in the Bats failure output. Plus, we want to ensure that
# 'set -o functrace' goes back into effect once the assertion has finished.
#
# Arguments:
#   $1:  The $BASH_SOURCE value from the assertion source file
#   $2:  Return value of the calling assertion; defaults to 0
return_from_bats_assertion() {
  local assertion_source_file="$1"
  local result="${2:-0}"

  if [[ "${BATS_CURRENT_STACK_TRACE[0]}" =~ $assertion_source_file ]]; then
    unset 'BATS_CURRENT_STACK_TRACE[0]'
  fi

  if [[ "${BATS_PREVIOUS_STACK_TRACE[0]}" =~ $assertion_source_file ]]; then
    unset 'BATS_PREVIOUS_STACK_TRACE[0]'
  fi

  set -o functrace
  return "$result"
}

# --------------------------------
# IMPLEMENTATION - HERE BE DRAGONS
#
# None of the functions below this line are part of the public interface.
# --------------------------------

# Common implementation for assertions that evaluate the Bats `$output` variable
#
# Arguments:
#   assertion:   The assertion to execute
#   constraint:  The assertion constraint used to evaluate $output
__assert_output() {
  local assertion="$1"
  local constraint="$2"

  if [[ "$#" -ne 2 ]]; then
    echo "ERROR: ${FUNCNAME[1]} takes exactly one argument" >&2
    __return_from_bats_assertion 1
  else
    "$assertion" "$constraint" "$output" 'output'
  fi
}

# Common implementation for assertions that evaluate a single `$lines` element
#
# Arguments:
#   assertion:   The assertion to execute
#   lineno:      The index into $lines identifying the line to evaluate
#   constraint:  The assertion constraint used to evaluate ${lines[$lineno]}
__assert_line() {
  local assertion="$1"
  local lineno="$2"
  local constraint="$3"

  # Implement negative indices for Bash 3.x.
  if [[ "${lineno:0:1}" == '-' ]]; then
    lineno="$((${#lines[@]} - ${lineno:1}))"
  fi

  if ! "$assertion" "$constraint" "${lines[$lineno]}" "line $lineno"; then
    printf 'OUTPUT:\n%s\n' "$output" >&2
    __return_from_bats_assertion 1
  else
    __return_from_bats_assertion
  fi
}

# Scrubs the Bats stacks of references to functions from this file
#
# See the comment for return_from_bats_assertion for details.
#
# Arguments:
#   $1:  Return value of the calling assertion; defaults to 0
__return_from_bats_assertion() {
  return_from_bats_assertion "$BASH_SOURCE" "$1"
}
