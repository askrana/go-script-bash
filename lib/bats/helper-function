#! /usr/bin/env bash
#
# Utilities for writing helper functions for Bats tests

# The first line of every Bats helper function must call `set` with this
# argument. See the function comments for `restore_bats_shell_options`.
export DISABLE_BATS_SHELL_OPTIONS='+eET'

# Restore shell options disabled with `set "$DISABLE_BATS_SHELL_OPTIONS"`.
#
# Ensures a Bats helper function failure points to its call, not its internals.
# This is critical for writing Bats assertion functions.
#
# You must ensure that `set "$DISABLE_BATS_SHELL_OPTIONS"` is in effect prior to
# calling this function, and that your Bats helper function calls this function
# directly through every return path (i.e. you can't delegate the call to
# another helper function). See the comments at the top of `lib/bats/assertions`
# for usage instructions and patterns.
#
# Notice that each public assertion starts with:
#
#   set "$DISABLE_BATS_SHELL_OPTIONS"`
#
# and that `DISABLE_BATS_SHELL_OPTIONS` is set to `+eET`. Bats uses `set -e`,
# `set -E`, and `set -T` (in `tests/bats/libexec/bats-exec-test`) to make sure
# failing commands are pinpointed and their stack traces are collected. This is
# almost always the desired behavior.
#
# When it comes to test assertions, however, we want the stack trace to point to
# the assertion call itself, not the line within its implementation at which a
# condition triggered the failure. Otherwise, it produces a bit of mental strain
# when reviewing test failures to identify the location of the failing assertion
# in the test case itself.
#
# Starting an assertion with `set "$DISABLE_BATS_SHELL_OPTIONS"` (i.e. `set
# +eET`) disables the `set -e`, `set -E`, and `set -T` shell options, which
# prevents the functions and commands it calls from updating the Bats stack
# traces. However, by itself, this still leaves the function, file, and line
# number where the assertion was defined in the Bats stack traces. It's also
# important to reinstate `set -eET` upon returning, but we want to make it easy
# to write new assertions composed from existing assertions by reinstating these
# options only when returning from the outermost assertion.
#
# This function solves both aspects of the problem by removing the immediate
# caller from the Bats stack traces and reinstating `set -eET` if it is the
# outermost assertion function, which will be the only one pushed onto the Bats
# stacks prior to calling `set "$DISABLE_BATS_SHELL_OPTIONS"`.
#
# Arguments:
#   result:  Return value of the calling assertion; defaults to 0
restore_bats_shell_options() {
  local result="${1:-0}"
  local target_stack_item_pattern=" ${FUNCNAME[1]} ${BASH_SOURCE[1]}$"

  if [[ "${BATS_CURRENT_STACK_TRACE[0]}" =~ $target_stack_item_pattern ]]; then
    # After removing our caller from BATS_CURRENT_STACK_TRACE and restoring the
    # Bats shell options, the `return` call at the end of the function will fire
    # `bats_debug_trap`, which sets BATS_CURRENT_STACK_TRACE to
    # BATS_PREVIOUS_STACK_TRACE.
    #
    # Then, if `result` is nonzero, `return` will fire `bats_error_trap`, which
    # sets BATS_ERROR_STACK_TRACE to BATS_PREVIOUS_STACK_TRACE, and the error
    # response will fail the test.
    unset 'BATS_CURRENT_STACK_TRACE[0]'
    set -eET
  fi
  return "$result"
}
export -f restore_bats_shell_options
