#! /bin/bash
#
# Functions for testing Bats assertions

TEST_SCRIPT="$BATS_TEST_ROOTDIR/do_test.bats"
export TEST_OUTPUT_FILE="$BATS_TEST_ROOTDIR/test-output.txt"

# Validates that an assertion succeeds for the provided inputs
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
expect_success() {
  local run_cmd="$1"
  local assertion="$2"
  local __assertion_output
  local __assertion_status

  __run_command_then_run_assertion_in_subshell "$run_cmd" "$assertion"

  if [[ "$__assertion_status" -ne '0' ]]; then
    printf "In subshell: expected passing status, actual %d\nOutput:\n%s\n" \
      "$__assertion_status" "$__assertion_output" >&2
    return 1
  fi
  __check_expected_output "$__assertion_output"

  # Although we expect the assertion under test to pass, this script injects a
  # failing assertion after it to check that the assertion under test calls
  # `return_from_bats_assertion` upon returning. If it doesn't, the failing
  # assertion will show the passing assertion's stack, per issue #48.
  __run_assertion_test_script \
    "  run $run_cmd" \
    "  $assertion" \
    '  assert_equal_numbers() { [ "$1" -eq "$2" ]; }' \
    '  assert_equal_numbers 0 1'

  __check_expected_output "$output" \
    '1..1' \
    "not ok 1 $BATS_TEST_DESCRIPTION" \
    "# (from function \`assert_equal_numbers' in file $TEST_SCRIPT, line 6," \
    "#  in test file $TEST_SCRIPT, line 7)" \
    "#   \`assert_equal_numbers 0 1' failed"
}

# Validates that an assertion fails for the provided inputs
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
#   expected:   The expected output of the assertion failure
expect_failure() {
  local run_cmd="$1"
  local assertion="$2"
  shift 2
  local __assertion_output
  local __assertion_status
  local i

  __run_command_then_run_assertion_in_subshell "$run_cmd" "$assertion"

  if [[ "$__assertion_status" -eq '0' ]]; then
    printf "In subshell: expected failure, but succeeded\nOutput:\n%s\n" \
      "$__assertion_output" >&2
    return 1
  fi

  __check_expected_output "$__assertion_output" "$@"
  __run_assertion_test_script "  run $run_cmd" "  $assertion"

  if [[ "$status" -eq '0' ]]; then
    printf "In script: expected failure, but succeeded\nOutput:\n%s\n" \
      "$output" >&2
    return 1
  fi

  __check_expected_output "$output" \
    '1..1' \
    "not ok 1 $BATS_TEST_DESCRIPTION" \
    "# (in test file $TEST_SCRIPT, line 5)" \
    "#   \`$assertion' failed" \
    "${@/#/# }"
}

# Calls `printf` on its arguments and returns an error
#
# Useful for generating some output and a failing status. Exported to make it
# available to generated test scripts.
#
# Globals:
#   PRINTF_ERROR:  If set, the function returns this value instead of 1
#
# Arguments:
#   ...:  Arguments to `printf`
printf_with_error() {
  printf "$@"
  return "${PRINTF_ERROR:-1}"
}
export -f printf_with_error

# Execute `printf` and write result to `TEST_OUTPUT_FILE`
#
# Since we can't really redirect output as part of an `expect_success` or
# `expect_failure` argument (it redirects the output from `eval run $run_cmd`),
# this encapsulates the redirection to `TEST_OUTPUT_FILE`.
#
# This function and `TEST_OUTPUT_FILE` are exported to make them available to
# generated test scripts.
#
# Arguments:
#   ...:  Arguments to `printf`
printf_to_test_output_file() {
  printf "$@" >"$TEST_OUTPUT_FILE"
}
export -f printf_to_test_output_file

# --------------------------------
# IMPLEMENTATION - HERE BE DRAGONS
#
# None of the functions below this line are part of the public interface.
# --------------------------------

# Passes the target command to `run`, the executes the `assertion` in a subshell
#
# The `run_cmd` is executed in-process to set `output`, `status`, and `lines`.
#
# The `assertion` is executed in a process substitution (subshell) so that its
# __assertion_output and __assertion_status can be captured and evaluated while
# leaving `output`, `status`, and `lines` intact for later checks. It's also
# able to capture trailing blank lines in the assertion output, which `run
# $assertion` would normally remove.
#
# Globals:
#   __assertion_status:  Caller-declared variable for the assertion status
#   __assertion_output:  Caller-declared variable for the assertion output
#
# Arguments:
#   run_cmd:    The full command to pass to `run` as a single string
#   assertion:  The full assertion to evaluate as a single string
__run_command_then_run_assertion_in_subshell() {
  local run_cmd="$1"
  local assertion="$2"
  local line

  eval run $run_cmd
  while IFS= read -r line; do
    line="${line%$'\r'}"
    if [[ "$line" =~ ^exit:([0-9]+)$ ]]; then
      __assertion_status="${BASH_REMATCH[1]}"
    else
      __assertion_output+="$line"$'\n'
    fi
  done < <(trap 'echo exit:$?' EXIT; eval $assertion 2>&1; exit "$?")

  # Trim trailing newline to match typical `output` behavior.
  __assertion_output="${__assertion_output%$'\n'}"
}

# Creates a test script from the arguments and runs it right away
#
# Arguments:
#   ...: Body of the test case to execute
__run_assertion_test_script() {
  create_bats_test_script "${TEST_SCRIPT#$BATS_TEST_ROOTDIR/}" \
    '#! /usr/bin/env bats' \
    "load '$_GO_CORE_DIR/lib/bats/assertions'" \
    "@test \"$BATS_TEST_DESCRIPTION\" {" \
    "$@" \
    '}'
  run "$TEST_SCRIPT"
}

# Compares the actual assertion failure output against the expected output
#
# Arguments:
#   actual_output:  Actual assertion output as a single string
#   ...:            Expected assertion output as a series of strings
__check_expected_output() {
  local actual_output="$1"
  local expected_output=("${@:2}")
  local IFS=$'\n'
  expected_output="${expected_output[*]}"

  if [[ "$actual_output" != "$expected_output" ]]; then
    printf 'Actual output differs from expected output:\n' >&2
    printf -- '--------\nEXPECTED:\n%s\n--------\nACTUAL:\n%s\n--------\n' \
      "$expected_output" "$actual_output" >&2
    return 1
  fi
}
