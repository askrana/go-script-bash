#! /bin/bash

_@go.set_search_paths_add_plugin_paths() {
  local plugin_paths=("$1"/*/bin)
  if [[ "${plugin_paths[0]}" != "$1/*/bin" ]]; then
    _GO_PLUGINS_PATHS+=("${plugin_paths[@]}")
  fi
  return 1
}

_@go.set_search_paths() {
  local plugin_path

  if [[ -n "$_GO_INJECT_SEARCH_PATH" ]]; then
    _GO_SEARCH_PATHS+=("$_GO_INJECT_SEARCH_PATH")
  fi
  _GO_SEARCH_PATHS+=("$_GO_CORE_DIR/libexec" "$_GO_SCRIPTS_DIR")

  # A plugin's own local plugin paths will appear before inherited ones. If
  # there is a version incompatibility issue with other installed plugins, this
  # allows a plugin's preferred version to take precedence.
  @go.search_plugins '_@go.set_search_paths_add_plugin_paths'

  # Ensure a plugin's _GO_SCRIPTS_DIR isn't duplicated in _GO_SEARCH_PATHS.
  for plugin_path in "${_GO_PLUGINS_PATHS[@]}"; do
    if [[ "$plugin_path" != "$_GO_SCRIPTS_DIR" ]]; then
      _GO_SEARCH_PATHS+=("$plugin_path")
    fi
  done
}

if [[ "${#_GO_SEARCH_PATHS[@]}" -eq 0 ]]; then
  _GO_PLUGINS_DIR="$_GO_SCRIPTS_DIR/plugins"
  _@go.set_search_paths
fi

_@go.list_available_commands() {
  . "$_GO_CORE_DIR/lib/internal/commands"
  local __go_command_names

  if ! _@go.find_commands "$@"; then
    echo "ERROR: No commands available in:" >&2
    local IFS=$'\n'
    echo "${@/#/  }" >&2
    return 1
  fi

  echo "Available commands are:"
  local IFS=$'\n'
  echo "${__go_command_names[*]/#/  }"
}

_@go.set_command_path_and_argv() {
  if [[ "$#" -eq '0' || -z "$*" ]]; then
    return 1
  fi

  local cmd_args=("$@")
  local cmd_name="${cmd_args[0]}"
  local cmd_path
  local try_path

  unset 'cmd_args[0]'

  for try_path in "${_GO_SEARCH_PATHS[@]}"; do
    try_path="$try_path/$cmd_name"

    if [[ -f "$try_path" && -x "$try_path" ]]; then
      cmd_path="$try_path"
      break
    elif [[ -e "$try_path" ]]; then
      @go.printf "$try_path is not an executable script\n" >&2
      return 1
    fi
  done

  if [[ -z "$cmd_path" ]]; then
    printf "Unknown command: ${cmd_name}\n\n" >&2
    _@go.list_available_commands "${_GO_SEARCH_PATHS[@]}" >&2
    return 1
  fi

  local cmd_arg_index=1
  __go_cmd_name=("$cmd_name")

  for arg in "${cmd_args[@]}"; do
    # This is most likely to happen during argument completion.
    if [[ -z "$arg" ]]; then
      break
    fi

    try_path="${cmd_path}.d/$arg"

    if [[ ! -e "$try_path" ]]; then
      break
    elif [[ ! (-f "$try_path" && -x "$try_path") ]]; then
      @go.printf "$try_path is not an executable script\n" >&2
      return 1
    fi

    __go_cmd_name+=("$arg")
    cmd_path="$try_path"
    unset "cmd_args[$((cmd_arg_index++))]"
  done

  __go_cmd_path="$cmd_path"
  __go_argv=("${cmd_args[@]}")
}
