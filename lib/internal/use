#! /bin/bash
#
# Imports optional Bash library modules
#
# Usage:
#   .  "$_GO_USE_MODULES" <module> [<module>...]
#
#   NOTE: It's important to wrap `$_GO_USE_MODULES` in double-quotes to ensure
#   the statement is portable to environments in which the file paths may
#   contain spaces. It's good practice to wrap each `<module>` in
#   single-quotes as well.
#
# Where:
#   <module>  The name of an optional Bash library module
#
# After sourcing `go-core.bash`, you can source the `_GO_USE_MODULES` script
# to import optional library code from the core framework, from plugins, or
# from your scripts directory. You can do so in your `./go` script, making the
# module code available to all your Bash command scripts, or use it in specfic
# Bash command scripts or Bash functions.
#
# This aims to be a convenient, flexible, standard, and self-documenting means
# of reusing Bash library code that incurs no overhead if such functionality
# isn't required by a project, just like other modern programming languages. In
# so doing, it aims to promote the development of modular, robust, and
# well-tested core framework extensions and other plugins without bloating
# project scripts that have no use for the extra functionality.
#
# For example, the core framework logging module `lib/log` is not sourced
# automatically by `go-core.bash`, so that scripts that don't make use of it
# will not incur the penalty of loading that code.  However, scripts that do
# make use of it need only invoke the following command in the `./go` script
# immediately after sourcing `go-core.bash`, and the core logging interface is
# then available to the rest of the `./go` script and any command scripts also
# written in Bash:
#
#   . "$_GO_USE_MODULES" 'log'
#
# Alternatively, specific command scripts or individual Bash functions that
# require the functionality can use `_GO_CORE_MODULES` on an as-needed basis,
# rather than using it in the top-level `./go` script.
#
# The precedence for discovering modules is (with examples from the "Directory
# structure" example from README.md):
#
#   - the `_GO_INJECT_MODULE_PATH` directory
#   - the `lib/` directory of the framework (`scripts/go-script-bash/lib`)
#   - the `lib/` directory in your project scripts directory (`scripts/lib`)
#   - the `lib/` directory of `_GO_ROOTDIR` (i.e. exported scripts)
#   - the `lib/` directory of installed plugins (`scripts/plugins/*/lib`)
#
# For modules contained in plugin directories, you must specify the path as
# `<plugin-name>/<module-name>`. There is no need to include the `lib/`
# component.  For example, if you have a plugin called `foo` and it contains a
# module file `lib/bar` (installed as `scripts/plugins/foo/lib/bar` in your
# project repository), you could import the module via:
#
#   . "$_GO_USE_MODULES" 'foo/bar'
#
# Note that if there is a module with the relative path `foo/bar` in one of the
# other directories, such as `_GO_ROOTDIR/lib/foo/bar`, it will take precedence
# over the plugin `scripts/plugins/foo/lib/bar`.
#
# Module loading is idempotent, as the names of imported modules are added to
# the `_GO_IMPORTED_MODULES` array and are not sourced again if their names are
# already in the array.
#
# To see what modules are currently imported and their corresponding files, use:
#
#   for modules imported by the top-level `./go` script:
#   {{go}} modules --imported
#
#   for modules imported within a Bash command script or function:
#   @go modules --imported

declare __go_module_name
declare __go_module_file
declare __go_loaded_module
declare __go_loaded_file
declare __go_module_index
declare __go_use_caller
declare __go_use_prev_caller

# Wrapper function necessary due to BASH_SOURCE and FUNCNAME bug in Bash <4.3.
_@go.set_use_caller() {
  __go_use_caller="${BASH_SOURCE[2]}:${BASH_LINENO[1]} ${FUNCNAME[2]}"
}

_@go.find_plugin_module_impl() {
  [[ -f "$1/$__go_module_file" ]] && __go_module_file="$1/$__go_module_file"
}

_@go.find_plugin_module() {
  # If a script imports a plugin module, and that module (`__go_use_caller`)
  # tries to import another module from the same plugin, this block will adjust
  # the search parameters accordingly.
  if [[ "$__go_use_caller" =~ ^$_GO_PLUGINS_DIR/.*/lib/ ]]; then
    local _GO_SCRIPTS_DIR="${__go_use_caller%/lib/*}/bin"

    __go_module_file="$_GO_SCRIPTS_DIR/lib/$__go_module_name"
    if [[ -f "$__go_module_file" ]]; then
      return
    fi
    __go_module_file="${__go_module_file%/bin/*}/lib/$__go_module_name"
    if [[ -f "$__go_module_file" ]]; then
      return
    fi
  fi

  # Convert <plugin>/<module> to plugins/<plugin>/lib/<module>
  __go_module_file="${__go_module_name/\///lib/}"
  @go.search_plugins '_@go.find_plugin_module_impl'
}

for __go_module_name in "$@"; do
  # Since every import is in the same scope, setting the caller each time is
  # necessary in case any imported modules import other modules.
  _@go.set_use_caller
  __go_module_file="$_GO_CORE_DIR/lib/$__go_module_name"

  if [[ -n "$_GO_INJECT_MODULE_PATH" ]]; then
    __go_module_file="$_GO_INJECT_MODULE_PATH/$__go_module_name"
    if [[ ! -f "$__go_module_file" ]]; then
      __go_module_file="$_GO_CORE_DIR/lib/$__go_module_name"
    fi
  fi

  if [[ ! -f "$__go_module_file" ]]; then
    __go_module_file="$_GO_SCRIPTS_DIR/lib/$__go_module_name"

    if [[ ! -f "$__go_module_file" ]]; then
      __go_module_file="$_GO_ROOTDIR/lib/$__go_module_name"

      if [[ ! -f "$__go_module_file" ]] && ! _@go.find_plugin_module; then
        @go.printf 'ERROR: Module %s not found at:\n' "$__go_module_name" >&2
        @go.print_stack_trace 1 >&2
        exit 1
      fi
    fi
  fi

  # If we found the module in our project, but we're installed as a plugin,
  # change the loaded module name to reflect that.
  #
  # Using `##` to trim the string instead of `#` flattens the module name
  # namespace. We could use `#` to keep it hierarchical, but since the Bash
  # namespace itself is flat, this might lead to hard-to-debug collisions if
  # functions and variables get redefined. Keeping a flat module name namespace
  # allows us to detect such potential collisions and issue a warning below.
  if [[ "$__go_module_file" =~ ^$_GO_PLUGINS_DIR ]]; then
    __go_module_name="${__go_module_file##*/plugins/}"
    __go_module_name="${__go_module_name/\/bin\///}"
    __go_module_name="${__go_module_name/\/lib\///}"
  fi

  __go_module_index=0
  for __go_loaded_module in "${_GO_IMPORTED_MODULES[@]}"; do
    if [[ "$__go_module_name" == "$__go_loaded_module" ]]; then
      __go_loaded_file="${_GO_IMPORTED_MODULE_FILES[$__go_module_index]}"
      __go_use_prev_caller="${_GO_IMPORTED_MODULE_CALLERS[$__go_module_index]}"

      # This may happen if a plugin appears more than once in a project tree.
      if [[ "$__go_module_file" != "$__go_loaded_file" ]]; then
        @go.printf '%s\n' "WARNING: Module: $__go_module_name" \
          "imported at: $__go_use_caller" \
          "from file: $__go_module_file" \
          "previously imported at: $__go_use_prev_caller" \
          "from file: $__go_loaded_file" >&2
      fi
      continue 2
    fi
    ((++__go_module_index))
  done

  # Prevent self- and circular importing by registering info before sourcing.
  _GO_IMPORTED_MODULES+=("$__go_module_name")
  _GO_IMPORTED_MODULE_FILES+=("$__go_module_file")
  _GO_IMPORTED_MODULE_CALLERS+=("$__go_use_caller")

  if ! . "$__go_module_file"; then
    @go.printf 'ERROR: Failed to import %s module from %s at:\n' \
      "$__go_module_name" "$__go_module_file" >&2
    @go.print_stack_trace 1 >&2
    exit 1
  fi
done

unset __go_use_prev_caller
unset __go_use_caller
unset __go_module_index
unset __go_loaded_file
unset __go_loaded_module
unset __go_module_file
unset __go_module_name
