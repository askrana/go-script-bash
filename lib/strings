#! /usr/bin/env bash
#
# String maniuplation functions
#
# Exports:
#   @go.split
#     Splits fields from a delimited string into an array defined by the caller
#
#   @go.join
#     Joins multiple items into a string variable defined by the caller
#
#   @go.common_prefix
#     Determines the common prefix for a set of strings
#
#   @go.remove_common_path_prefix
#     Removes the common path prefix from a set of file paths
#
# These functions help avoid `IFS`-related pitfalls as described by:
#
#   http://mywiki.wooledge.org/Arguments

. "$_GO_USE_MODULES" 'validation'

# Splits fields from a delimited string into an array defined by the caller
#
# While `IFS= read -ra array_name <<<"$value"` is idiomatic, this function
# guards against a bug in Bash 4.2.25 (the version in the Ubuntu Precise image
# used by Travis CI) and not fixed until 4.2.41 whereby the temporary
# environment of `IFS= read` isn't honored when running in a process
# substitution. For details, see the message for commit
# 99ab7805e6ef0a14568d8a100eec03bb2cb03631.
#
# Strangely `while IFS= read` does work as expected. See the message for commit
# 2297b48e3851323c9bfcb567ad794ec58a846d1b.
#
# Note that there is no way to escape the delimiter value to make it appear as a
# valid character in a field.
#
# Arguments:
#   delimiter:   The character separating individual fields
#   value:       The string to split into individual fields
#   array_name:  Name of caller's array variable into which to store fields
@go.split() {
  @go.validate_identifier_or_die 'Result array name' "$3"
  local IFS="$1"
  read -ra "$3" <<<"$2"
}

# Joins multiple items into a string variable defined by the caller
#
# Encapsulates the use of `IFS` to avoid polluting other portions of the script,
# and to avoid the need for saving and restoring the original `IFS` value.
#
# Arguments:
#   delimiter:  The character separating individual fields
#   var_name:   Name of caller's variable to which to assign the joined string
#   ...:        Elements to join into a string assigned to `var_name`
@go.join() {
  @go.validate_identifier_or_die 'Result variable name' "$2"
  local IFS="$1"
  printf -v "$2" -- '%s' "${*:3}"
}

# Determines the common prefix for a set of strings
#
# Will return the empty string for a single argument. This facilitates prefix
# removal without requiring that the caller check that there is more than one
# element in an array of strings to avoid checking for the special case of a
# single string being its own prefix.
#
# Arguments:
#   var_name:   Name of caller's variable to which to assign the common prefix
#   ...:        Strings to examine to determine the common prefix
@go.common_prefix() {
  @go.validate_identifier_or_die 'Result variable name' "$1"
  local _gcp_prefix="$2"
  local _gcp_prefix_len="${#_gcp_prefix}"
  local _gcp_item

  for _gcp_item in "${@:3}"; do
    while [[ "${_gcp_item:0:$_gcp_prefix_len}" != "$_gcp_prefix" ]]; do
      ((--_gcp_prefix_len))
      _gcp_prefix="${_gcp_prefix:0:$_gcp_prefix_len}"
    done
    if [[ "$_gcp_prefix_len" -eq '0' ]]; then
      break
    fi
  done

  if [[ "$#" -lt '3' ]]; then
    _gcp_prefix=''
  fi
  printf -v "$1" -- '%s' "$_gcp_prefix"
}

# Removes the common path prefix from a set of file paths
#
# Arguments:
#   array_name:  Name of caller's array into which to store the updated paths
#   ...:         File paths from which to remove the common path prefix
@go.remove_common_path_prefix() {
  @go.validate_identifier_or_die 'Result variable name' "$1"
  local _grcpp_prefix
  local _grcpp_paths=("${@:2}")

  @go.common_prefix '_grcpp_prefix' "${_grcpp_paths[@]}"

  if [[ "$_grcpp_prefix" =~ / ]]; then
    _grcpp_prefix="${_grcpp_prefix%/*}/"
  else
    _grcpp_prefix=''
  fi

  local IFS=$'\x1f'
  read -ra "$1" <<<"${_grcpp_paths[*]#$_grcpp_prefix}"
}
